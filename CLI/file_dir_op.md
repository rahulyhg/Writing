
## 文件操作和目录操作的命令  

* `cp`		复制文件和目录  
* `mv`		移动/重命名文件和目录  
* `mkdir`	创建目录  
* `rm`		删除文件和目录  
* `ln`		创建硬链接和符号链接  


## 通配符  

shell提供了特殊字符来帮助你快速指定一组文件名，这些特殊字符叫做通配符  
下面是通配符以及他们的意义:  

	通配符			意义
	*				匹配任意多个字符(>=0)
	?				匹配任意一个字符(不包括0)
	[characters]	匹配任意一个属于字符集中的字符
	[!characters]	匹配任意一个不属于字符集中的字符
	[[:class:]]		匹配任意一个属于指定字符类中的字符

下面是些常用的字符类:  

	字符类		意义
	[:alnum:]	匹配任意一个字母和数字
	[:alpha:]	匹配任意一个字母
	[:digit:]	匹配任意一个数字
	[:lower:]	匹配任意一个小写字母
	[:upper:]	匹配任意一个大写字母

借助通配符，为文件名构建非常复杂的选择标准成为可能  
下面是一些类型匹配的范例:  

	模式			匹配对象
	*				所有文件
	g*				文件名以"g"开头的文件
	b*.txt			以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件
	Data???			以"Data"开头，其后紧接着3个字符的文件
	[abc]*			文件名以"a","b"或"c"开头的文件
	BACKUP.[0-9][0-9][0-9]	
		以"BACKUP."开头，并紧接着3个数字的文件
	[[:upper:]]*	以大写字母开头的文件
	[![:digit:]]*	不以数字开头的文件
	*[[:lower:]123] 文件名以小写字母结尾，或以"1","2",或"3"结尾的文件

接受文件名作为参数的任何命令,都可以使用通配符  

[A-Z]或[a-z]形式的字符范围表示法，这些都是传统的UNIX表示法，并且在早期的Linux版本有效  

虽然他们仍然起作用，但是必须谨慎使用，因为他们可能不会按照你的期望输出结果,除非你合理的配置  

从现在开始，应该避免使用他们，用且用字符类带代替他们  

## mkdir--创建目录

`mkdir`命令是用来创建目录的:`mkdir direcroty...`  

**注意:**在描述一个命令时，当有三个圆点跟在命令后，这意味着那个参数可以重复  

因此，`mkdir`一次可以创建多个目录  

	$ mkdir ~/test1 ~/test2 ~/test3

此命令创建了三个目录:~/test1,~/test2,~/test3  

## cp--复制文件和目录  

一些常用的选项:  

	选项			意义
	-a				复制文件和目录，并且保留其权限，时间戳

	-i				在重写已存在文件之前，提示用户确认

	-r				递归地复制目录及其目录中的内容

	-u				当把文件从一个目录复制到另一个目录时
					仅复制目标目录中不存在的文件,或者是文件
					内容新于目标目录中已经存在的文件

	-v				显示详细地命令操作信息


一些实例:  

复制目录 dir1 中的内容到目录 dir2。  
如果目录 dir2 不存在,创建目录 dir2,操作完成后,目录 dir2 中的内容和 dir1 中的一样。  
如果目录 dir2 存在,则目录 dir1(和目录中的内容) 将会被复制到 dir2 中  

	$ cp -r dir1 dir2

复制文件到目标目录，并更新(当来源文件比目标文件新)其下相应文件:  

	$ cp -u *.html destination/

## mv--移动和重命名文件

`-i`, `-u`, `-v`  

## rm--删除文件和目录

`-i`, `-r`, `-f`, `-v`  
	
`-f`：忽视不存在的文件,但是`-if`的时候，`-i`的作用会消失；当`-fi`的时候，`-f`的作用会消失  

Linux中没有回收站这种东西，所以Linux删除的东西，就彻底消失了，除非使用硬盘恢复工具  
因此，在使用rm命令用到通配符的时候，用ls命令测试通配符，这会让你看到要删除的文件列表，如果是你想要的结果，那么就放心删除吧  

## ln--创建链接  

链接分为硬链接和符号链接  

	$ ls -l file1.txt
	-rw-rw-r-- 1 liluo liluo 0  2月  5 20:23 file1.txt
	$ ln file1.txt file2.txt
	$ ls -l file[[:digit:]].txt
	-rw-rw-r-- 2 liluo liluo 0  2月  5 20:23 file1.txt
	-rw-rw-r-- 2 liluo liluo 0  2月  5 20:23 file2.txt

这是创建硬链接，发现创建前后`ls -l`结果的第2列由`1`变成了`2`,然后其他一切信息都没变化，包括时间戳信息  

	$ ls -l file1.txt
	-rw-rw-r-- 3 liluo liluo 0  2月  5 20:23 file1.txt
	$ ln -s file1.txt file4.txt
	$ ls -l file1.txt file4.txt
	-rw-rw-r-- 3 liluo liluo 0  2月  5 20:23 file1.txt
	lrwxrwxrwx 1 liluo liluo 9  2月  5 20:33 file4.txt -> file1.txt
这是创建符号链接，注意观察创建前后`ls -l`结果的第2列的变化，创建链接前后中源文件值未变，而链接文件的值为1,而且链接文件有个箭头指向源文件  

### 硬链接

硬链接最初是UNIX创建链接的方式，而符号链接则更加现代   

一个文件对应唯一的索引节点  

在`ls -li`的第一列是索引节点，第三列就是硬链接个数  
当你使用`touch link`创建一个文件时，可以看到它的硬链接个数为1  
当你使用`ln link hard-link`创建一个硬链接时，可以看到硬链接和源文件的索引节点是一样的  

所以，默认情况下，每个文件有一个硬链接,或者说就是一个硬链接  

当为一个文件创建一个硬链接，删除源文件后，并不影响链接文件，文件内容并未丢失,这就是说磁盘空间不会被重新分配  

所以，直到所有关联这个文件的硬链接都删除掉(包括源文件)，这个文件才会被删除掉  

硬链接的两个重要的局限性:  

1. 一个硬链接不能关联它所在文件系统之外的文件，即一个链接不能关联与链接本身不再同一磁盘分区上的文件  

2. 一个硬链接不能关联一个目录  


### 符号链接

创建符号链接是为了克服硬链接的局限性  

符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的指针  
这和Windows的快捷方式到是有些相似,但比Windows的快捷方式早了好多年  

一个符号链接指向一个文件  
当你删除符号链接，并不影响源文件内容和其他符号链接  
但是当你删除源文件，那么所有执行此源文件的符号链接都会失效，这种情况下，这个链接被称为坏链接  

可以使用`file file-name`查看符号链接属性，进行前后对比:  
	
	$ touch fun
	$ ln -s fun soft-link		# 创建一个符号链接
	$ file soft-link			# 查看符号链接的属性
	soft-link: symbolic link to `fun'
	$ rm fun					# 删除源文件
	$ file soft-link			# 再次查看符号链接的属性
	soft-link: broken symbolic link to `fun'

使用`ln`命令指定相对路径的话，一旦符号链接移动就失效了  
但是使用绝对路径的话，符号链接即使移动到别的目录也不会失效  

Linux系统中损坏的符号链接在`ls`命令下显示红色，而好的符号链接则显示青色  




